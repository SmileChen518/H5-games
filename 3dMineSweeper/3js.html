<!DOCTYPE html>
<html>
<head>
    <title></title>
    <style>canvas { width: 100%; height: 100% }</style>
    <script src="../libs/three.js"></script>
    // <script src='../libs/stats.js'></script>
    <script src='../libs/TrackballControls.js'></script>
     // <script src='../libs/VTKLoader.js'></script>
    // <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
</head>
<body>
	<script>
		var stats, renderer, camera, scene, light, group, geometry, materials, controls;
		var btn, mine, empty;
		function initParas(){
			materials = [];
			//纹理		
			var grid = new THREE.MeshBasicMaterial( { map: new THREE.TextureLoader().load( 'textures/grid.png' ) } );
			btn = [ new THREE.Vector2(0, .833), new THREE.Vector2(.33, .833), new THREE.Vector2(.33, 1), new THREE.Vector2(0, 1) ];
			empty = [ new THREE.Vector2(0, 0), new THREE.Vector2(.33, 0), new THREE.Vector2(.33, .166), new THREE.Vector2(0, .166) ];
			// var 
			materials.push(grid);
		}
		function initTween(){
			// new TWEEN.Tween( group.position)
   //          .to( { x: -400 }, 3000 ).repeat( Infinity ).start();
		}
		function initStat() {
        	stats = new Stats();
			stats.setMode(0); // 0: fps, 1: ms
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.left = '0px';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
        }
		function initRederer(){
			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
		}
		function initCamera(){
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			// camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 10, 1000 );
			camera.position.set( 0, 0, 100 );
		}
		function initScene(){
			scene = new THREE.Scene();
		}
        function initLight() {
        	// light = new THREE.AmbientLight(0x00FF00);
        	// scene.add(light);
            light = new THREE.DirectionalLight(0xFFFFFF, 1, 0);
            light.position.set(0, 1, 1);
            // scene.add(light);
            // light = new THREE.PointLight(0x0000FF);
            // light.position.set(0, 0, 100);
            scene.add(light);
        }
        function setGrid(geometry, img){
        	geometry.faceVertexUvs[0][8] = [ img[0], img[1], img[3] ];
			geometry.faceVertexUvs[0][9] = [ img[1], img[2], img[3] ];
        }
        // 扫雷格子
		function initGroup(){
			group = new THREE.Group();
			var LENGTH = 10, COUNT = 9, INTER = 0, OFFSET = (LENGTH+INTER)*(COUNT-1)/2; 
			geometry = new THREE.CubeGeometry( LENGTH, LENGTH, LENGTH );
			setGrid(geometry, btn);
			// setGrid(geometry, empty);

			mesh = new THREE.Mesh( geometry, materials[0] );
			mesh.position.set(-OFFSET, OFFSET, 0);
			group.add(mesh);
			// for (var i = 0; i < COUNT; i++) for (var j = 0; j < COUNT; j++) for (var z = 0; z < 1; z++){
			// 	if (i == 0 && j == 0 && z == 0) continue;
			// 	var temp = mesh.clone();
			// 	temp.position.set((LENGTH+INTER)*j-OFFSET, -(LENGTH+INTER)*i+OFFSET, (LENGTH+INTER)*z);
			// 	group.add(temp);
			// }
			scene.add( group );
			window.addEventListener( 'resize', onWindowResize, false );
		}
		function initGrid(){
            var helper = new THREE.GridHelper( 1000, 50 );
            helper.rotation.x = Math.PI/4;
            scene.add( helper );
        }
		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );
			controls.handleResize();
		}
		function animate() {
			// group.rotation.x += 0.005;
			// group.rotation.y += 0.01;
			renderer.render( scene, camera );
			requestAnimationFrame( animate );
			controls.update();
			// stats.update();
			// TWEEN.update();
		}
		function init(){
			initParas();
			initMines();
			// initStat();
			initRederer();
			initCamera();
			initScene();
			// initLight();
			initControls();
			initGrid();
			initGroup();
			// initTween();
			animate();
			addEventListener('click', onMouseClick, false);
		}
		// 鼠标双击触发的方法
	    function onMouseClick(event) {

	        // 获取 raycaster 和所有模型相交的数组，其中的元素按照距离排序，越近的越靠前
	        var intersects = getIntersects(event);

	        // 获取选中最近的 Mesh 对象
	        if (intersects.length != 0 && intersects[0].object instanceof THREE.Mesh) {
	            // intersects[0].object.material = materials[1];
	            setGrid(intersects[0].object.geometry, empty);
	        } else {
	            // alert("未选中 Mesh!");
	        }
	    }
	    // 获取与射线相交的对象数组
	    function getIntersects(event) {
	        event.preventDefault();

	        // 声明 raycaster 和 mouse 变量
	        var raycaster = new THREE.Raycaster();
	        var mouse = new THREE.Vector2();

	        // 通过鼠标点击位置,计算出 raycaster 所需点的位置,以屏幕为中心点,范围 -1 到 1
	        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
	        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

	        //通过鼠标点击的位置(二维坐标)和当前相机的矩阵计算出射线位置
	        raycaster.setFromCamera(mouse, camera);

	        //获取group下的mesh
	        var scensObjs = [];
		    scene.children.forEach(child => {
			    for (var i = 0; i < child.children.length; i++) {
			      var obj=child.children[i];
			      scensObjs.push(obj);
			    }
		    });
		    // 获取与射线相交的对象数组，其中的元素按照距离排序，越近的越靠前
	        var intersects = raycaster.intersectObjects(scensObjs);

	        //返回选中的对象
	        return intersects;
	    }

	    // 初始化轨迹球控件
	    function initControls() {
	        controls = new THREE.TrackballControls(camera, renderer.domElement);
	        // controls.noRotate = true;
	        // controls.noPan = true;
	        controls.rotateSpeed = 5.0;
			controls.zoomSpeed = 5;
			controls.panSpeed = 2;

			controls.noZoom = false;
			controls.noPan = false;

			controls.staticMoving = false;
			controls.dynamicDampingFactor = 0.3;
	    }
		function initMines(){
			var tNum = [];
	        var tMineNum = [];
	        _tNum = [];
	        _tFlag = [];
	        _tBtns = [];
	        _tMine = [];
	        _iTotal = 81;
	        _iMineCount = 10;
	        for (var i = 0; i < _iTotal; i++) {
	            tNum.push(i);
	            tMineNum[i] = 0;
	            _tNum[i] = 0;
	            _tFlag[i] = 0;
	            _tBtns[i] = 1;
	            // this._tBtns[i] = 0;
	        };
            for (var i = 0; i < _iMineCount; i++) {
                var iRandom = Math.floor(Math.random() * (tNum.length - 1));
                var iNum = tNum.splice(iRandom, 1);
                tMineNum[iNum] = 1;
            };
	        // this._tileMap.showMines(tMineNum);
	        for (var i = 0; i < _iTotal; i++) {
	            if (tMineNum [i] == 1) {
	                _tMine.push(i);
	                _tNum[i] = -1;
	            }
	        };
		}
		function initLabs(){

		}
		function showGrids(idxNum){
	 //        var _iRow = this._iRow;
	 //        var iLabNum = this._tNum [idxNum];
	 //        if (iLabNum >= 0) {
	 //            this._tBtns[idxNum] = 0;
	 //            if (iLabNum == 0) {
	 //                var iMine = parseInt(idxNum);
	 //                var iCurLine = Math.floor (iMine / _iRow);
	 //                var iCurRow = iMine % _iRow;
	 //                for (var iLine = 0; iLine < 3; iLine++) {
	 //                    for (var iRow = 0; iRow < 3; iRow++) {
	 //                        var iRowTemp = iCurRow - 1 + iRow;
	 //                        var iLineTemp = iCurLine - 1 + iLine;
	 //                        if (iRowTemp > -1 && iRowTemp < _iRow && iLineTemp > -1 && iLineTemp < this._iLine) {
	 //                            var idx = iMine + (iRow - 1) + (iLine * _iRow - _iRow);
	 //                            if (this._tFlag[idx] == 0 && this._tBtns[idx] == 1 && this._tSearch.indexOf(idx) == -1) {
	 //                                this._tSearch.push(idx);
	 //                                this.showGrids (idx);
	 //                            }
	 //                        }
	 //                    }
	 //                }
	 //            }
	 //        }
	    }
	    function onClickNum(idxNum){
	    //     var _iRow = this._iRow;
	    //     var iMine = parseInt(idxNum);
	    //     var iCurLine = Math.floor (iMine / _iRow);
	    //     var iCurRow = iMine % _iRow;
	    //     //统计标记的地雷数量，标错return;
	    //     var iShowNum = 0;
	    //     for (var iLine = 0; iLine < 3; iLine++) {
	    //         for (var iRow = 0; iRow < 3; iRow++) {
	    //             var iRowTemp = iCurRow - 1 + iRow;
	    //             var iLineTemp = iCurLine - 1 + iLine;
	    //             if (iRowTemp > -1 && iRowTemp < _iRow && iLineTemp > -1 && iLineTemp < this._iLine) {
	    //                 var idx = iMine + (iRow - 1) + (iLine * _iRow - _iRow);
	    //                 if (this._tFlag[idx] == 1) {
	    //                     iShowNum++;
	    //                 }
	    //             }
	    //         }
	    //     }
	    //     //判断地雷是否均被标记
	    //     if (this._tNum[idxNum] != iShowNum)
	    //         return;
	    //     this.playSound("check");
	    //     this.setTSearch();
	    //     //展开地图
	    //     for (var iLine = 0; iLine < 3; iLine++) {
	    //         for (var iRow = 0; iRow < 3; iRow++) {
	    //             var iRowTemp = iCurRow - 1 + iRow;
	    //             var iLineTemp = iCurLine - 1 + iLine;
	    //             if (iRowTemp > -1 && iRowTemp < _iRow && iLineTemp > -1 && iLineTemp < this._iLine) {
	    //                 var idx = iMine + (iRow - 1) + (iLine * _iRow - _iRow);
	    //                 if (this._tFlag[idx] == 0){
	    //                     if (this._tNum[idx] == -1){
	    //                         this._tBtns[idx] = 0;
	    //                         this.playSound("bomb");
	    //                         this._tileMap.showRedMine(idx);
	    //                         this.onEnd();
	    //                         this._tileMap.strBack = "bomb";
	    //                         break;
	    //                     }
	    //                     if (this._tBtns[idx] == 1){
	    //                         if (this._tSearch.indexOf(idx) == -1) {
	    //                             this._tSearch.push(idx);
	    //                             this.showGrids (idx);
	    //                         }
	    //                     }
	    //                 }
	    //             }
	    //         }
	    //     };
	    //     this._tileMap.showBtns(this._tBtns);
	    //     this.showWin();
	    }
		init();
    </script>
   <!--  <div>
	    Fov:<input type="text" value="45" id="txtFov"/>
	</div> -->
</body>
</html>
